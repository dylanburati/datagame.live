<section class="mt-8">
  <div class="flex flex-row pb-2">
    <h2 id="sheet-title" class="text-oneline">Loading sheet...</h2>
    <span class="flex-grow" style="width: 1rem;"></span>
    <button id="refresh" class="bg-blue interactable mr-2">‚Üª</button>
    <button id="publish" class="bg-green interactable">Publish</button>
  </div>
  <div id="control-container" class="hidden flex flex-row align-center flex-wrap mb-5">
    <button class="bg-surface mb-2 p-1 mr-2 interactable" style="min-width: 3.5ex">üîç</button>
    <select class="interactable mb-2 py-1-5" aria-label="Deck Picker"></select>
    <input type="text" class="hidden mb-2" style="width: 200px;" placeholder="Search">
    <span class="flex-grow" style="width: 1rem;"></span>
    <nav role="navigation" class="mb-2" aria-label="Pagination Navigation">
      <ul class="pagination">
      </ul>
    </nav>
  </div>
  <p id="error-box" class="text-red hidden"></p>
  <ul id="warning-list" class="hidden list-disc list-inside mb-5 px-5 py-2 border rounded border-yellow-400">
  </ul>
  <div id="publish-container" class="mb-5 hidden">
    <pre class="bg-surface p-3 text-sm leading-tight"></pre>
  </div>
  <div style="overflow-x: auto">
    <table id="sheet-table" class="border-t">
    </table>
  </div>
</section>

<script type="text/javascript">
const apiShowUrl = "<%= Routes.url(@conn) <> Routes.sheet_path(@conn, :show, "") %>";
const apiCreateUrl = "<%= Routes.url(@conn) <> Routes.sheet_path(@conn, :create) %>";

const effects = [];

const checkEffects = () => {
  effects.forEach(effect => {
    const { func, depFunc, last } = effect;
    const deps = depFunc();
    let mismatch = !last || deps.length !== last.length;
    for (let i = 0; !mismatch && i < deps.length; i++) {
      mismatch = mismatch || deps[i] !== last[i];
    }
    if (mismatch) {
      effect.last = deps;
      func();
    }
  })
};

const useEffect = (func, depFunc) => {
  effects.push({ func, depFunc, last: undefined });
  checkEffects();
}

const setter = (setState) => {
  return x => {
    setState(x);
    checkEffects();
  };
}

const titleEl = document.getElementById('sheet-title');
const controls = document.getElementById('control-container');
const controlSwitcher = document.querySelector('#control-container button');
const searchInput = document.querySelector('#control-container input');
const pagination = document.querySelector('#control-container nav ul');
const deckPicker = document.querySelector('#control-container select');
const errorBox = document.getElementById('error-box');
const warningList = document.getElementById('warning-list');
const table = document.getElementById('sheet-table');
const refreshBtn = document.getElementById('refresh');
const publishBtn = document.getElementById('publish');
const publishContainer = document.getElementById('publish-container');
const publishCodeblock = publishContainer.querySelector('pre');
let refreshEnabled = true;
let publishEnabled = true;
let sheetData = null;
const setSheetData = setter(val => { sheetData = val; });
let tableData = null;
const setTableData = setter(val => { tableData = val; });
let currentPage = 1;
const setCurrentPage = setter(val => { currentPage = val; });
let deckName = null;
const setDeckName = setter(val => { deckName = val; });
let query = '';
const setQuery = setter(val => {
  query = val;
  searchInput.value = val;
});

let pageSize = 50;

function modify(el, removeChildren, attrs, children) {
  if (removeChildren) {
    Array.from(el.children).forEach(c => c.remove());
  }
  if (attrs.style) {
    Object.assign(el.style, attrs.style);
  }
  for (const k in attrs) {
    if (k.startsWith('on')) {
      el.addEventListener(k.slice(2).toLowerCase(), attrs[k]);
    } else if (k !== 'style') {
      if (attrs[k] === true) el.setAttribute(k, '');
      else if (attrs[k] !== false) el.setAttribute(k, attrs[k]);
    }
  }
  for (let child of children) {
    if (typeof child === 'string' || typeof child === 'number') {
      el.insertAdjacentText('beforeend', String(child));
    } else {
      el.appendChild(child);
    }
  }
  return el;
}

function h(tagName, attrs, ...children) {
  const el = document.createElement(tagName);
  const childArr = [];
  children.forEach(item => {
    if (Array.isArray(item)) {
      childArr.push(...item);
    } else {
      childArr.push(item);
    }
  });
  return modify(el, false, attrs, childArr);
}

function repaginate() {
  if (tableData == null) return;

  const pageTotal = Math.ceil((tableData.length - 1) / pageSize);

  const getMiddle = n => {
    switch (n) {
      case 1: return [n + 1, n + 2].filter(x => x < pageTotal);
      case 2: return [n, n + 1, n + 2].filter(x => x < pageTotal);
      case pageTotal - 1: return [n - 2, n - 1, n].filter(x => x > 1);
      case pageTotal: return [n - 2, n - 1].filter(x => x > 1);
      default: return [n - 1, n, n + 1];
    }
  };

  const pages = getMiddle(currentPage);
  if (pages[0] > 1) {
    if (pages[0] > 2) {
      pages.unshift('...')
    }
    pages.unshift(1);
  }
  if (pages[pages.length - 1] < pageTotal) {
    if (pages[pages.length - 1] < pageTotal - 1) {
      pages.push('...');
    }
    pages.push(pageTotal);
  }

  const oldPageLinks = {};
  const separators = {};
  Array.from(pagination.children).forEach((child, i) => {
    if (child.textContent === '...') {
      const which = i === 1 ? 'left' : 'right';
      separators[which] = child;
    } else {
      oldPageLinks[child.textContent] = child;
    }
  });
  pagination.replaceChildren(
    ...pages.map((pg, i) => {
      if (pg === '...') {
        const which = i === 1 ? 'left' : 'right';
        return separators[which] || h('span', { style: { margin: '0 0.25rem' } }, '...');
      }
      const attrs = {
        active: pg === currentPage,
        class: 'interactable',
        onClick: () => {
          setCurrentPage(pg);
        },
      };
      if (String(pg) in oldPageLinks) {
        if (pg === currentPage) {
          oldPageLinks[String(pg)].querySelector('button').setAttribute('active', '');
        } else {
          oldPageLinks[String(pg)].querySelector('button').removeAttribute('active');
        }
      }
      return oldPageLinks[String(pg)] || h('li', {}, h('button', attrs, pg));
    })
  );
}

useEffect(repaginate, () => [deckName, tableData, currentPage]);

function populateTable() {
  if (tableData == null) {
    modify(table, true, {}, []);
    warningList.classList.add('hidden');
    return;
  }

  const { deck, warnings } = tableData;
  if (warnings.length) {
    warningList.classList.remove('hidden');
    modify(warningList, true, {},
      warnings.map(txt => h('li', { class: 'text-sm' }, txt))
    );
  } else {
    warningList.classList.add('hidden');
  }
  const rowNums = new Array(pageSize).fill(0)
    .map((_, i) => (currentPage - 1) * pageSize + i)
    .filter(e => e < tableData.length);
  modify(table, true, {}, [
    h('thead', {},
      deck.map(col =>
        h('th', {}, col.name)
      )
    ),
    h('tbody', {},
      rowNums.map(n =>
        h('tr', {},
          deck.map(({ rows }) =>
            h('td', { class: 'text-sm p-1' }, n < rows.length ? rows[n] : '')
          )
        )
      )
    )
  ]);
}

useEffect(populateTable, () => [tableData, currentPage]);

function calculateTableData() {
  if (!sheetData || !deckName) {
    setTableData(null);
    return;
  }
  const deck = sheetData.decks.find(d => d.title === deckName);
  if (!deck) {
    setTableData(null);
    return;
  }

  const warnings = [];
  const first = (arr) => arr.length ? arr[0] : null;
  const tagLabelPos = deck.values.findIndex((col, i, arr) =>
    first(col) === 'Column' && i + 1 < arr.length && first(arr[i + 1]) === 'Label'
  );
  const tagLabels = {};
  if (tagLabelPos !== -1) {
    const kCol = deck.values[tagLabelPos];
    const vCol = deck.values[tagLabelPos + 1];
    for (let i = 1; i < Math.min(kCol.length, vCol.length); i++) {
      if (kCol[i].startsWith('Tag') && vCol[i]) {
        tagLabels[kCol[i]] = vCol[i];
      }
    }
  } else {
    warnings.push("Tags don't have labels")
  }
  const showCols = [];
  const disabledRows = new Set();
  const disableMapCol = deck.values.find(col => col[0] === 'Disable?');
  if (disableMapCol !== undefined) {
    disableMapCol.forEach((e, i) => {
      if (e && i > 0) disabledRows.add(i - 1);
    });
  } else {
    warnings.push("No column named 'Disable?'");
  }
  const filteredRows = new Set();
  let stopAtCol = deck.values.findIndex(col => col[0] === 'Notes');
  if (stopAtCol === -1) {
    warnings.push("No column named 'Notes'");
  }
  if (query) {
    const queryL = query.toLowerCase();
    for (const col of deck.values.slice(0, stopAtCol + 1)) {
      if (col.length > 1 && col[0] !== 'Disable?' && col[0] !== 'ID') {
        col.forEach((cell, i) => {
          if (i > 0 && cell.toLowerCase().includes(queryL)) {
            filteredRows.add(i - 1);
          }
        });
      }
    }
  }

  let longCol = [];
  let numRows = 0;
  let popColCount = null;
  let cardColCount = null;
  const tagColCounts = {};
  const countOccurrences = (acc, cur, i) => {
    if (cur !== '' && !disabledRows.has(i)) {
      acc.total += 1;
      acc.grouped[cur] = (acc.grouped[cur] || 0) + 1;
    }
    return acc;
  };
  const countTagOccurrences = (acc, cur, i) => {
    if (cur !== '' && !disabledRows.has(i)) {
      acc.total += 1;
      const tagList = cur.split(/\s*,\s*/);
      for (const tag of tagList) {
        acc.grouped[tag] = (acc.grouped[tag] || 0) + 1;
      }
      acc.multi = acc.multi || tagList.length > 1;
    }
    return acc;
  };
  const countTypes = (acc, cur, i) => {
    if (!disabledRows.has(i)) {
      const typ =
        cur === ''
          ? 'empty'
          : Number.isNaN(parseFloat(cur, 10))
          ? 'string'
          : 'number'
      acc[typ] = (acc[typ] || 0) + 1;
    }
    return acc;
  };
  for (const col of deck.values.slice(0, stopAtCol + 1)) {
    if (col.length > 1 && col[0] !== 'Disable?' && col[0] !== 'ID') {
      const colRep = {
        name: tagLabels[col[0]] || col[0],
        rows: col.slice(1).filter((_, i) =>
          !disabledRows.has(i) && (!query || filteredRows.has(i))
        ),
      };
      showCols.push(colRep);
      if (col.length > longCol.length) {
        longCol = col;
        numRows = colRep.rows.length;
      }
      if (col[0].startsWith('Tag')) {
        if (!tagLabels[col[0]]) {
          warnings.push(`Column '${col[0]}' needs a descriptive label`);
        }
        tagColCounts[col[0]] = col.slice(1).reduce(countTagOccurrences, {
          total: 0,
          grouped: {},
          multi: false
        });
      } else if (col[0] === 'Popularity') {
        popColCount = col.slice(1).reduce(countTypes, {});
      } else if (col[0] === 'Card') {
        cardColCount = col.slice(1).reduce(countOccurrences, {
          total: 0,
          grouped: {},
        });
      }
    }
  }
  const enabledCount = longCol.length - 1 - disabledRows.size;
  if (!cardColCount) {
    warnings.unshift("Error: column 'Card' is required");
  } else {
    if (cardColCount.total < enabledCount) {
      warnings.push(
        `Column 'Card' is blank for ${enabledCount - cardColCount.total} cells - ` +
        'these will be dropped'
      );
    }
    Object.entries(cardColCount.grouped).filter(([k, v]) => v > 1).forEach(([card, c]) => {
      warnings.push(`Card value '${card.replace(/\n/g, "‚Æê")}' appears ${c} times`);
    });
  }
  if (!popColCount) {
    warnings.push("Column 'Popularity' is not filled out");
  } else {
    if (popColCount['empty'] > 0) {
      warnings.push(
        `Column 'Popularity' is blank for ${popColCount['empty']} cells - ` +
        'these will be considered as difficult as the least well-known card'
      );
    }
    if (popColCount['string'] > 0) {
      warnings.push(
        `Column 'Popularity' is not a number for ${popColCount['string']} cells - ` +
        'these will be considered as difficult as the least well-known card'
      );
    }
  }
  if (!tagColCounts['Tag1']) {
    warnings.push("Column 'Tag1' is not filled out - the game customization sliders will be disabled");
  } else {
    counts1 = tagColCounts['Tag1'];
    if (counts1.multi) {
      warnings.push("Column 'Tag1' should not have multiple values in any cell");
    }
    if (counts1.total < enabledCount) {
      warnings.push(
        `Column 'Tag1' is blank for ${enabledCount - counts1.total} cells - ` +
        "these will add a 'N/A' slider in the game customization menu"
      );
    }
    const smallGroups = [];
    Object.entries(counts1.grouped).forEach(([tag, size]) => {
      if (size < 10) {
        smallGroups.push(tag);
      }
    });
    smallGroups.forEach(tag => {
      warnings.push(`Fewer than 10 cards have the primary tag: ${tag}`);
    });
    const gCount = Object.keys(counts1.grouped).length;
    if (gCount > 10) {
      warnings.push(
        `Column 'Tag1' has ${gCount} categories - the game customization menu only allows 10`
      );
    }
  }
  setTableData({
    deck: showCols,
    length: numRows,
    warnings,
    rowNumLookup: n => lut[n],
  });
}

useEffect(calculateTableData, () => [deckName, sheetData, query]);

useEffect(() => {
  if (sheetData == null) {
    return;
  }
  modify(deckPicker, true, {},
    sheetData.decks.map(d => h('option', { value: d.title }, d.title.replace('Deck:', '', 1)))
  );
}, () => [sheetData]);

async function refresh() {
  refreshEnabled = false;
  titleEl.textContent = "Loading sheet...";
  errorBox.classList.add('hidden');
  controls.classList.add('hidden');
  publishContainer.classList.add('hidden');
  setSheetData(null);
  setCurrentPage(1);
  setDeckName(null);
  setQuery('');

  try {
    const response = await fetch(`${apiShowUrl}${new URL(window.location).searchParams.get('id')}`);
    const json = await response.json();
    if (json.error) {
      throw new Error(json.error);
    } else {
      controls.classList.remove('hidden');
      titleEl.textContent = json.title;
      setDeckName(json.decks[0].title);
      setSheetData(json);
    }
  } catch (err) {
    errorBox.classList.remove('hidden');
    titleEl.textContent = 'Error';
    errorBox.textContent = err;
  } finally {
    refreshEnabled = true;
  }
}
refresh();

refreshBtn.addEventListener('click', () => {
  if (refreshEnabled) {
    refresh();
  }
});

deckPicker.addEventListener('change', evt => {
  setDeckName(evt.target.selectedOptions[0].value);
  setQuery('');
});

controlSwitcher.addEventListener('click', evt => {
  if (Array.from(searchInput.classList).includes('hidden')) {
    controlSwitcher.textContent = '‚ò∞'
  } else {
    controlSwitcher.textContent = 'üîç'
  }
  searchInput.classList.toggle('hidden');
  deckPicker.classList.toggle('hidden');
});

searchInput.addEventListener('input', evt => {
  setQuery(evt.target.value);
  setCurrentPage(1);
});

async function publish() {
  if (sheetData == null) return;

  try {
    publishEnabled = false;
    const resp = await fetch(apiCreateUrl, {
      method: "POST",
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(sheetData),
    });
    const json = await resp.json();
    console.log(json);
    publishContainer.classList.remove('hidden');
    publishCodeblock.textContent = JSON.stringify(json, null, 2);
  } catch (err) {
    console.error(err);
  } finally {
    publishEnabled = true;
  }
}

publishBtn.addEventListener('click', () => {
  if (publishEnabled) {
    publish();
  }
});
</script>
